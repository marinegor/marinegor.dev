<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Biweekly GSOC-1: decomposing `AnalysisBase.run()` - marinegor.dev</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="In the first GSOC-devoted blogpost I explained the idea behind my proposal and the approximate timeline for its execution.
Here I&rsquo;ll go through the initial implementation stages &ndash; how I decided to decompose the run() method for the AnalysisBase so that I could paralellize the execution, which changes it&rsquo;ll require, and how not to break all the existing code in the process. Let&rsquo;s go!
AnalysisBase protocol AnalysisBase is a superclass for most of the MDAnalysis objects that perform the actual analysis of trajectories." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="http://localhost:1313/posts/gsoc-2023/2023-06-16-gsoc-2/">
  <meta property="og:site_name" content="marinegor.dev">
  <meta property="og:title" content="Biweekly GSOC-1: decomposing `AnalysisBase.run()`">
  <meta property="og:description" content="In the first GSOC-devoted blogpost I explained the idea behind my proposal and the approximate timeline for its execution.
Here I’ll go through the initial implementation stages – how I decided to decompose the run() method for the AnalysisBase so that I could paralellize the execution, which changes it’ll require, and how not to break all the existing code in the process. Let’s go!
AnalysisBase protocol AnalysisBase is a superclass for most of the MDAnalysis objects that perform the actual analysis of trajectories.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-06-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-06-16T00:00:00+00:00">
    <meta property="article:tag" content="Gsoc">
    <meta property="article:tag" content="Coding">
    <meta property="article:tag" content="Mdanalysis">
<meta name="twitter:card" content="summary"><meta name="twitter:title" content="Biweekly GSOC-1: decomposing `AnalysisBase.run()`">
<meta name="twitter:description" content="In the first GSOC-devoted blogpost I explained the idea behind my proposal and the approximate timeline for its execution.
Here I&rsquo;ll go through the initial implementation stages &ndash; how I decided to decompose the run() method for the AnalysisBase so that I could paralellize the execution, which changes it&rsquo;ll require, and how not to break all the existing code in the process. Let&rsquo;s go!
AnalysisBase protocol AnalysisBase is a superclass for most of the MDAnalysis objects that perform the actual analysis of trajectories.">
<script src="http://localhost:1313/js/feather.min.js"></script>
	
	
        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css" media="(prefers-color-scheme: dark)"  />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">marinegor.dev</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/about">About</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Biweekly GSOC-1: decomposing `AnalysisBase.run()`</h1>
			<div class="meta">Posted on Jun 16, 2023</div>
		</div>
		

		<section class="body">
			<p>In the first GSOC-devoted <a href="https://marinegor.github.io/posts/2023/05/gsoc-proposal/">blogpost</a> I explained the idea behind my proposal and the approximate timeline for its execution.</p>
<p>Here I&rsquo;ll go through the initial implementation stages &ndash; how I decided to decompose the <code>run()</code> method for the <code>AnalysisBase</code> so that I could paralellize the execution, which changes it&rsquo;ll require, and how not to break all the existing code in the process. Let&rsquo;s go!</p>
<h1 id="analysisbase-protocol"><code>AnalysisBase</code> protocol</h1>
<p><code>AnalysisBase</code> is a superclass for most of the MDAnalysis objects that perform the actual analysis of trajectories. If we omit some house-keeping arguments, Its current implementation works roughly like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AnalysisBase</span>(object):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> __init__(self, trajectory):
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Initialize the run object
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_trajectory <span style="color:#f92672">=</span> trajectory
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>results <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self, start, stop, step, frames):
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Perform the calculation
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_setup_frames(self<span style="color:#f92672">.</span>_trajectory, start<span style="color:#f92672">=</span>start, stop<span style="color:#f92672">=</span>stop,
</span></span><span style="display:flex;"><span>						   step<span style="color:#f92672">=</span>step, frames<span style="color:#f92672">=</span>frames)
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_prepare()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> i, ts <span style="color:#f92672">in</span> enumerate(self<span style="color:#f92672">.</span>_sliced_trajectory):
</span></span><span style="display:flex;"><span>			self<span style="color:#f92672">.</span>_frame_index <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>			self<span style="color:#f92672">.</span>_ts <span style="color:#f92672">=</span> ts
</span></span><span style="display:flex;"><span>			self<span style="color:#f92672">.</span>frames[i] <span style="color:#f92672">=</span> ts<span style="color:#f92672">.</span>frame
</span></span><span style="display:flex;"><span>			self<span style="color:#f92672">.</span>times[i] <span style="color:#f92672">=</span> ts<span style="color:#f92672">.</span>time
</span></span><span style="display:flex;"><span>			self<span style="color:#f92672">.</span>_single_frame()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_conclude()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> self
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_setup_frames</span>(self, trajectory, start, stop, step, frames):
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Prepare frames that will be used for the analysis
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_sliced_trajectory <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>start <span style="color:#f92672">=</span> start
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>stop <span style="color:#f92672">=</span> stop
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>step <span style="color:#f92672">=</span> step
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>n_frames <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>frames <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>times <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_single_frame</span>(self, <span style="color:#f92672">...</span>): <span style="color:#75715e"># implemented in subclasses</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Perform calculations on a single frame
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>		do_some_computations()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_prepare</span>(self, <span style="color:#f92672">...</span>): <span style="color:#75715e"># implemented in subclasses</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Prepare the storage attributes for intermediate results
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_intermediate_data <span style="color:#f92672">=</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_conclude</span>(self, <span style="color:#f92672">...</span>): <span style="color:#75715e"># implemented in subclasses</span>
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		Use the intermediate results to create the final ones
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>results <span style="color:#f92672">=</span> some_function_of(self<span style="color:#f92672">.</span>_intermediate_data)
</span></span></code></pre></div><p>Most of the computations happen in the <code>run</code> method &ndash; namely, here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i, ts <span style="color:#f92672">in</span> enumerate(self<span style="color:#f92672">.</span>_sliced_trajectory):
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_frame_index <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_ts <span style="color:#f92672">=</span> ts
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>frames[i] <span style="color:#f92672">=</span> ts<span style="color:#f92672">.</span>frame
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>times[i] <span style="color:#f92672">=</span> ts<span style="color:#f92672">.</span>time
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_single_frame()
</span></span></code></pre></div><p>So we must somehow parallelize the <code>_single_frame()</code> method, and make it run in separate processes simultaneously.</p>
<h1 id="where-to-apply-dask-parallelization">Where to apply <code>dask</code> parallelization?</h1>
<p>The parallelization in <code>dask</code>, which was our framework of choice (and also was used earlier in <code>pmda</code>), works roughly like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> dask.delayed <span style="color:#f92672">import</span> delayed
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@delayed</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">simple_computation</span>(x, y):
</span></span><span style="display:flex;"><span>	do_something()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>parameter_space <span style="color:#f92672">=</span> [(x,y) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">6</span>) <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span><span style="color:#f92672">**</span><span style="color:#ae81ff">6</span>)]
</span></span><span style="display:flex;"><span>computations <span style="color:#f92672">=</span> delayed([simple_computation(x, y) <span style="color:#66d9ef">for</span> x, y <span style="color:#f92672">in</span> parameter_space])
</span></span><span style="display:flex;"><span>results <span style="color:#f92672">=</span> computations<span style="color:#f92672">.</span>compute()
</span></span></code></pre></div><p>At the last line, <code>dask</code> spawns the computations among all workers &ndash; it serializes the <code>simple_computation</code> function and its arguments, sends them to the workers (which are either independent processes or even independent machines), does the computation and returns the results again via serialization.</p>
<p>Unfortunately, our case is a bit more complex than that: <code>_single_frame</code> uses many attributes of the <code>AnalysisBase</code> class itself &ndash; namely, those that are being set up before the <code>_single_frame</code> in the loop, and also those that each subclass might want to set up in their <code>_prepare</code> block. Hence, we should serialize the whole class instance, together with all its attributes. But then we can&rsquo;t do <code>_single_frame</code> a <code>delayed</code> function, because then each <code>delayed</code> function will carry the whole serialized class instance with it, and just blow up the memory of any local or remote computer.
Also, <code>_single_frame()</code> does some things internally, modifying the class instance, and returns <code>None</code> after that. So if we were to make each <code>_single_frame()</code> a <code>delayed</code> function, we&rsquo;ll gather the <code>None</code> values in our <code>results</code> after that, which is kind of silly.</p>
<p>So, we should split the computations in parts, and submit each part to its separate worker. Within each part, we&rsquo;ll have our own set of frames for computation, and then will collect all the results from these parts somewhere inside the &ldquo;main&rdquo; instance&rsquo;s run. For the purpose of continuity with <code>pmda</code>, we&rsquo;ll call these parts <strong>balanced slices</strong>, or <strong>bslices</strong>.</p>
<p>Setting up the frames for the computation in each worker would be a tedious task. Luckily, we have the function exactly for these purposes: <code>AnalysisBase._setup_frames()</code> does exactly this! It sets up all the necessary attributes in the class instance in a way that if we run <code>self.run()</code> after that, we&rsquo;ll be able to successfully iterate only through frames that were prepared.</p>
<h1 id="introducing-_compute-method">Introducing <code>_compute()</code> method</h1>
<p>For now, each serialized instance is getting its own set of frames, <code>bslice</code>, and works with that. Let&rsquo;s separate all this work into a separate <code>_compute()</code> method. How would it look like?</p>
<p>First, it should explicitly know the frames it was configured to work with &ndash; we&rsquo;ll pass them as arguments. Second, it should configure the class instance for computations &ndash; by running <code>_setup_frames</code>. Third, it should run the computation loop &ndash; the one that used to be in the <code>run</code> method, and in order for it to run properly, we should run <code>_prepare()</code> first</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_compute</span>(self, start, stop, step, frames):
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_setup_frames(<span style="color:#f92672">...</span>, start, stop, step, frames)
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_prepare()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i, ts <span style="color:#f92672">in</span> enumerate(self<span style="color:#f92672">.</span>_sliced_trajectory):
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_frame_index <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_ts <span style="color:#f92672">=</span> ts
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>frames[i] <span style="color:#f92672">=</span> ts<span style="color:#f92672">.</span>frame
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>times[i] <span style="color:#f92672">=</span> ts<span style="color:#f92672">.</span>time
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_single_frame()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> self	
</span></span></code></pre></div><p>Now, since we&rsquo;re explicitly returning <code>self</code> here, we will have our <code>self.results</code> attribute, and won&rsquo;t loose it while sending it to the other workers.</p>
<h1 id="decomposition-or-run">Decomposition or <code>run()</code></h1>
<p>So, <code>run</code> is becoming more complex &ndash; it lacks the computation loop now, but has many other methods to control the computational flow itself.
The only thing left to do now is to collect all the results together from all the workers. In a way, it&rsquo;s a <code>_conclude</code> method for the parallel part, so we&rsquo;ll call it <code>_parallel_conclude()</code>, with the whole method now looking like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self, start, stop, step, frames):
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	Perform the calculation
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_setup_bslices(<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>	computations <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> bslice <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>_bslices:
</span></span><span style="display:flex;"><span>		start, stop, step, frames <span style="color:#f92672">=</span> bslice
</span></span><span style="display:flex;"><span>		computations<span style="color:#f92672">.</span>append(delayed((self<span style="color:#f92672">.</span>_compute)(start, stop, step, frames)))
</span></span><span style="display:flex;"><span>	results <span style="color:#f92672">=</span> computations<span style="color:#f92672">.</span>compute()
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_remote_results <span style="color:#f92672">=</span> results
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_parallel_conclude()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_conclude()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> self
</span></span></code></pre></div><p>How should the <code>_parallel_conclude()</code> look like? Well, we have a list of instances of the executed <code>AnalysisBase</code> subclass in our <code>_remote_results</code> attribute. If each of them has their own <code>results</code>, it would look somewhat like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_parallel_conclude</span>(self):
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>results <span style="color:#f92672">=</span> some_aggregation_function(self<span style="color:#f92672">.</span>_remote_results)
</span></span></code></pre></div><p>Unfortunately, here we can&rsquo;t avoid subclass-specific implementation &ndash; every computation is different by how it collects its intermediate results (in fact, <code>AnalysisBase.results</code> actually has its own <code>Results</code> type, which is essentially a dictionary, and can hold arbitrary data). But it&rsquo;s ok, at least the <code>run</code> process itself is now parallelized.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We now have an outline for the parallel execution of the <code>AnalysisBase.run()</code> method, which contains proper splitting of the frames into balanced slices, and running the computation loop on each of the balanced slices. We didn&rsquo;t pay much attention to the scheduling part of it, and how it&rsquo;ll affect the control flow, but we&rsquo;ll come back to it later in the future posts of these series!</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/gsoc">gsoc</a></li>
					
					<li><a href="/tags/coding">coding</a></li>
					
					<li><a href="/tags/mdanalysis">mdanalysis</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/marinegor" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a><a class="soc" href="https://twitter.com/egor__marin/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
    <a class="border"></a><a class="soc" href="https://www.linkedin.com/in/marinegor/" rel="me" title="Linkedin"><i data-feather="linkedin"></i></a>
    <a class="border"></a><a class="soc" href="https://bsky.app/profile/marinegor.bsky.social" rel="me" title="Bluesky"><i data-feather="bluesky"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2024  Egor Marin |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>
<script>
  feather.replace()
</script></div>
    </body>
</html>
