<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Biweekly GSOC-2: splitting the work and writing `_setup_bslices` - marinegor.dev</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="In the previous blogpost, I briefly explained how I&rsquo;m planning to decompose the AnalysisBase.run() method, so that its subclasses won&rsquo;t notice the changes in the protocol, but at the same time will be able to perform computations in a parallel manner.
Here I&rsquo;ll go through the implementation details of some methods &ndash; namely, I&rsquo;ll explain how I went to a certain implementation of _setup_bslices, _compute and run.
Where are we right now?" />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="http://localhost:1313/posts/gsoc-2023/biweekly-2_splitting/">
  <meta property="og:site_name" content="marinegor.dev">
  <meta property="og:title" content="Biweekly GSOC-2: splitting the work and writing `_setup_bslices`">
  <meta property="og:description" content="In the previous blogpost, I briefly explained how I’m planning to decompose the AnalysisBase.run() method, so that its subclasses won’t notice the changes in the protocol, but at the same time will be able to perform computations in a parallel manner.
Here I’ll go through the implementation details of some methods – namely, I’ll explain how I went to a certain implementation of _setup_bslices, _compute and run.
Where are we right now?">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-06-30T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-06-30T00:00:00+00:00">
    <meta property="article:tag" content="Gsoc">
    <meta property="article:tag" content="Coding">
    <meta property="article:tag" content="Mdanalysis">
<meta name="twitter:card" content="summary"><meta name="twitter:title" content="Biweekly GSOC-2: splitting the work and writing `_setup_bslices`">
<meta name="twitter:description" content="In the previous blogpost, I briefly explained how I&rsquo;m planning to decompose the AnalysisBase.run() method, so that its subclasses won&rsquo;t notice the changes in the protocol, but at the same time will be able to perform computations in a parallel manner.
Here I&rsquo;ll go through the implementation details of some methods &ndash; namely, I&rsquo;ll explain how I went to a certain implementation of _setup_bslices, _compute and run.
Where are we right now?">
<script src="http://localhost:1313/js/feather.min.js"></script>
	
	
        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css" media="(prefers-color-scheme: dark)"  />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">marinegor.dev</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/about">About</a>
		
		<a href="/tags">Tags</a>
		
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Biweekly GSOC-2: splitting the work and writing `_setup_bslices`</h1>
			<div class="meta">Posted on Jun 30, 2023</div>
		</div>
		

		<section class="body">
			<p>In the previous <a href="https://marinegor.github.io/posts/2023/06/gsoc-biweekly-1">blogpost</a>, I briefly explained how I&rsquo;m planning to decompose the <code>AnalysisBase.run()</code> method, so that its subclasses won&rsquo;t notice the changes in the protocol, but at the same time will be able to perform computations in a parallel manner.</p>
<p>Here I&rsquo;ll go through the implementation details of some methods &ndash; namely, I&rsquo;ll explain how I went to a certain implementation of <code>_setup_bslices</code>, <code>_compute</code> and <code>run</code>.</p>
<h2 id="where-are-we-right-now">Where are we right now?</h2>
<p>At this moment, the <code>AnalysisBase.run()</code> method looks roughly like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self, start, stop, step, frames):
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	Perform the calculation
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_setup_bslices(<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>	computations <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> bslice <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>_bslices:
</span></span><span style="display:flex;"><span>		start, stop, step, frames <span style="color:#f92672">=</span> bslice
</span></span><span style="display:flex;"><span>		computations<span style="color:#f92672">.</span>append(delayed((self<span style="color:#f92672">.</span>_compute)(start, stop, step, frames)))
</span></span><span style="display:flex;"><span>	results <span style="color:#f92672">=</span> computations<span style="color:#f92672">.</span>compute()
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_remote_results <span style="color:#f92672">=</span> results
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_parallel_conclude()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_conclude()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> self
</span></span></code></pre></div><p>Let&rsquo;s think of how <code>_setup_bslices</code> should look like &ndash; which arguments it has and what it returns, or which attributes of <code>self</code> modifies?</p>
<p>Well, clearly, it should know about the computation limits defined earlier in the <code>run</code> itself. Also, it should know about the scheduling parameters, in order to be able to distribute the load more or less evenly. Also, we know that we&rsquo;ll iterate over <code>self._bslices</code> in the <code>run()</code>, so we want to assign this attribute at the end. So, something like that:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_setup_bslices</span>(self, start, stop, step, frames, scheduler):
</span></span><span style="display:flex;"><span>	n_parts <span style="color:#f92672">=</span> some_function_of(scheduler)
</span></span><span style="display:flex;"><span>	bslices <span style="color:#f92672">=</span> split_evenly(start, stop, step, frames)
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_bslices <span style="color:#f92672">=</span> bslices
</span></span></code></pre></div><p>Now, the first part with <code>n_parts = ...</code> is actually simple. For now, for clarity, we&rsquo;ll just specify <code>scheduler</code> as a string that represents the scheduling backend &ndash; either additionally installed <code>dask</code>, built-in <code>multiprocessing</code>, or <code>None</code> representing execution in the current process, and <code>n_parts</code> will be <code>n_workers</code> &ndash; a parameter of a scheduler.</p>
<h2 id="what-are-we-actually-splitting">What are we actually splitting?</h2>
<p>In order to split the work correctly, we need to know how exactly it looks like. In MDAnalysis, there are 2 mutually exclusive ways to define which frames you want to analyze:</p>
<ul>
<li><code>start, stop, step</code> &ndash; a triplet of integer numbers with semantics similar to those in <code>range</code></li>
<li><code>frames</code> &ndash; an iterable that works as a <code>slice</code> over trajectory. Can be of two kinds:
<ul>
<li><code>frames: Iterable[int]</code> &ndash; an iterable with numbers of frames for analysis. For example, <code>frames = list(range(0, len(trajectory)))</code> will be equivalent to <code>start=0, stop=len(trajectory), step=1</code></li>
<li><code>frames: Iterable[bool]</code> &ndash; an iterable with boolean values that define which frames to take into account. For example, <code>frames = [bool(i%2) for i in range(len(trajectory))]</code> is equivalent to <code>start=1, stop=len(trajectory), step=2</code></li>
</ul>
</li>
</ul>
<p>Now our task is to accept one of those parameters, and correctly split it into roughly equal parts, each of which will go to a separate worker. First of all, let&rsquo;s simplify our task and note that accepting <code>start, stop, step</code> is equivalent to <code>frames = list(range(start, stop, step))</code>. Moreover, using <code>frames: Iterable[bool]</code> is actually equivalent to using <code>frames: Iterable[int] = np.arange(len(trajectory))[frames]</code>. Now it&rsquo;s the only case we have to work with! Neat.</p>
<p>In order to split an iterable into <code>n</code> equal parts, one could start writing some iterator-based functions in python, spend some time debugging it, etc &ndash; just like I did initially. Or be slightly smarter and google an appropriate function &ndash; turns out, <code>np.array_split</code> does exactly what we need.</p>
<p>Now, the splitting function needs to first match the type of our parameters, and then apply <code>np.array_split</code> single split. Something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">split_work_into_parts</span>(n_parts: int <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, start<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, stop<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, step<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, frames<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> any([opt <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span> <span style="color:#66d9ef">for</span> opt <span style="color:#f92672">in</span> (start, stop, step)]): <span style="color:#75715e"># using `start-stop-step` notation</span>
</span></span><span style="display:flex;"><span>		frames <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(start, stop, step)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>: <span style="color:#75715e"># using `frames` notation</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> is_iterable_of_booleans(frames):
</span></span><span style="display:flex;"><span>			frames <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(len(frames))[frames]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	frames <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array_split(frames, n_parts)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> frames
</span></span></code></pre></div><p>where <code>is_iterable_of_booleans(frames: Iterable)</code> looks something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_iterable_of_booleans</span>(arr: Iterable):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> all((isinstance(obj, bool) <span style="color:#66d9ef">for</span> obj <span style="color:#f92672">in</span> arr))
</span></span></code></pre></div><p>Unfortunately for us, we can&rsquo;t simply use the result of <code>split_work_into_parts</code> &ndash; we not only need to split the frames evenly, but we also have to keep track of frame indices we&rsquo;re using, since in <code>_compute</code> we&rsquo;re explicitly assigning <code>self._frame_index = i</code>. Hence, we have to use something like <code>enumerate</code> before creating balanced slices, and make our function slightly more complicated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">split_work_into_parts</span>(n_parts: int <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, start<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, stop<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, step<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, frames<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> any([opt <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span> <span style="color:#66d9ef">for</span> opt <span style="color:#f92672">in</span> (start, stop, step)]): <span style="color:#75715e"># using `start-stop-step` notation</span>
</span></span><span style="display:flex;"><span>		frames <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(start, stop, step)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>: <span style="color:#75715e"># using `frames` notation</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> is_iterable_of_booleans(frames):
</span></span><span style="display:flex;"><span>			frames <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(len(frames))[frames]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	frames <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(list(enumerate(frames)))
</span></span><span style="display:flex;"><span>	frames <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array_split(frames, n_parts)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> frames
</span></span></code></pre></div><p>Neat! Now we can get back to writing <code>_setup_bslices</code>.</p>
<h2 id="writing-_setup_bslices-and-using-self_bslices">Writing <code>_setup_bslices</code> and using <code>self._bslices</code></h2>
<p>Given all functions above, the target method will now look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_setup_bslices</span>(self, start, stop, step, frames, n_workers):
</span></span><span style="display:flex;"><span>	equal_iterables <span style="color:#f92672">=</span> split_work_into_parts(n_parts<span style="color:#f92672">=</span>n_workers, start, stop, step, frames)
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_bslices <span style="color:#f92672">=</span> equal_iterables
</span></span></code></pre></div><p>Now, we want to use these <code>bslices</code> in <code>run</code> method. We could get both indices and frames from <code>self._bslices</code> and then use them when creating list of computations, but since <code>self._bslices</code> will anyway get passed to the worker objects, let&rsquo;s just use a bslice index for assigning work, hence simplifying the <code>run</code> code. Like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self, start, stop, step, frames, n_workers, scheduler):
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_setup_frames(start, stop, step, frames)
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_prepare()
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_setup_bslices(start, stop, step, frames, n_workers)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> scheduler <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#75715e"># we have no worker processes and only one `bslice`</span>
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_compute(bslice_idx<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">from</span> dask.delayed <span style="color:#f92672">import</span> delayed
</span></span><span style="display:flex;"><span>		computations <span style="color:#f92672">=</span> [delayed(self<span style="color:#f92672">.</span>_compute)(bslice_idx) <span style="color:#66d9ef">for</span> bslice_idx <span style="color:#f92672">in</span> range(len(self<span style="color:#f92672">.</span>_bslices))]
</span></span><span style="display:flex;"><span>		results <span style="color:#f92672">=</span> computations<span style="color:#f92672">.</span>compute()
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_remote_results <span style="color:#f92672">=</span> results
</span></span><span style="display:flex;"><span>		self<span style="color:#f92672">.</span>_parallel_conclude()
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	self<span style="color:#f92672">.</span>_conclude()
</span></span></code></pre></div><p>And usage of <code>_compute</code> will also slightly change, since we&rsquo;re using bslice_idx instead of original <code>run</code>-inherited syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_compute</span>(self, bslice_idx):
</span></span><span style="display:flex;"><span>	bslice <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>_bslices[bslice_idx]
</span></span><span style="display:flex;"><span>	frame_indices, frames <span style="color:#f92672">=</span> bslices[:, <span style="color:#ae81ff">0</span>], bslices[:, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">for</span> idx, ts <span style="color:#f92672">in</span> enumerate(trajectory):
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> frame_indices[idx]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_frame_index <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_ts <span style="color:#f92672">=</span> ts
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>frames[i] <span style="color:#f92672">=</span> ts<span style="color:#f92672">.</span>frame
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>times[i] <span style="color:#f92672">=</span> ts<span style="color:#f92672">.</span>time
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_single_frame()
</span></span></code></pre></div><p>And that&rsquo;s it! This is really the core protocol of the <code>AnalysisBase.run()</code> method.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We now know crucial part of the parallelization works &ndash; splitting work into equal parts and communicating between those parts. We haven&rsquo;t yet touched on aggregation of these results &ndash; we only know that all workers, together with their results, will be stored in <code>self._remote_results: list[AnalysisBase]</code>, but we are yet to find out how to retrieve the main <code>AnalysisBase</code> results from these objects.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/gsoc">gsoc</a></li>
					
					<li><a href="/tags/coding">coding</a></li>
					
					<li><a href="/tags/mdanalysis">mdanalysis</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/marinegor" rel="me" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a><a class="soc" href="https://twitter.com/egor__marin/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
    <a class="border"></a><a class="soc" href="https://www.linkedin.com/in/marinegor/" rel="me" title="Linkedin"><i data-feather="linkedin"></i></a>
    <a class="border"></a><a class="soc" href="https://bsky.app/profile/marinegor.bsky.social" rel="me" title="Bluesky"><i data-feather="bluesky"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2024  Egor Marin |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>
<script>
  feather.replace()
</script></div>
    </body>
</html>
